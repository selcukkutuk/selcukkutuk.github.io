{"pages":[{"title":"Ben Kimim ?","text":"ÖzetKısa bir özet Eğitim HayatımEğitim bilgileri İş Deneyimlerimİş deneyimleri ile ilgili bilgiler HedeflerimKariyerimde ulaşmak istedilerim","link":"/benkimim/index.html"}],"posts":[{"title":"NuxtJs Uygulamanızı Github Actions ile Surge.sh’a Deploy Etme","text":"Github Actions duyurulduğunda hemen kayıt oldum ve heyecanla beklemeye başladım. Hesabım için aktif olduğunda ise bir deneme fırsatı bulamadım. Bugün temel anlamda basit bir nuxtjs uygulaması nasıl deploy ediliyor diye baktım. Burada örneği nuxtjs ile yapıyor olmamın aslında hiçbir önemi bulunmuyor. Bugün nuxtjs ile bir PoC yapıyordum ve bunu Github Actions ile nasıl deploy edebilirim dedim ve başladım. O zaman adım adım ne yapıyoruz birlikte inceleyelim. Surgesh için token oluşturalımDeploy etmek için kullanacağımız servis surge.sh olacak. Bu nedenle deploy aşamasında kullanacağımız bir token almamız gerekiyor. Tabi bu işlemi yapabilmemiz için surge cli’ı kurmamız gerekli. Bunu aşağıda yer alan komut ile gerçekleştiriyoruz. 1npm install -g surge Şimdi sıra geldi token almaya. Bunu da aşağıda yer alan komut ile gerçekleştiriyoruz. Alttaki resimde doğrudan token verildiğini göreceksiniz. Eğer surge cli’ı ilk kez çalıştırıyorsanız cli sizden bir kullanıcı adı ve şifre talep edecek ve sonrasında token alabileceksiniz. 1surge token NuxtJs uygulamamızı oluşturalımŞimdi bir nuxtjs uygulaması oluşturalım ve bunu github depomuza gönderelim. Not: NuxtJs uygulaması oluşturma adımlarını hızlıca geçiyor olacağım. NuxtJs kurulum sayfasından detaylı bilgi edinilebilir. Buradaki asıl amacım bunun Github Actions ile nasıl deploy edildiğidir. NuxtJs takımının bize sunmuş olduğu scaffolding tool ile uygulamamızı oluşturalım. 1npx create-nuxt-app nuxt-github-actions-surge Github hesabımızda yeni bir depo oluşturalım ve kodumuzu oraya gönderelim. NuxtJs uygulamasının ana dizininde aşağıdaki komutları çalıştırıyoruz. 1234567891011#Uygulamada değişiklik yaptıysanız bunları index'e ekliyoruz.git add .#Değişiklikleri yerel depodaki HEAD'e ediyoruzgit commit -m 'init'#Depomuza uzak sunucu adresi ekliyoruzgit remote add origin https://github.com/username/repo-name.git#Değişiklikleri sunucudaki master dalımıza gönderiyoruzgit push -u origin master Artık kodlarımız Github depomuza gittiğine göre askiyona başlayalım. :) Github ActionsArtık bit git deposu ve içerisinde bir nuxtjs uygulamamız bulunuyor. Bizim bunu surge.sh tarafına göndermekte dahil olmak üzere yapmamız gereken bir işlemler dizisi bulunuyor. İşte bu işlemler dizisine workflow yani iş akışı diyoruz. O zaman bir tane de kendi depomuz için oluşturalım. “Set up a workflow yourself” butonuna tıklayarak yeni bir iş akışı ayarlamaya başlayalım. Bizi ikinci adımda aşağıdaki ekran karşılayacak. Kırmızı içerisine aldığım bölüm iş akışı tanımını yapacağımız düzenleyici. Şimdi o bölümü aşağıdaki bölüm ile değiştirelim. 123456789101112131415161718name: Deploy Websiteon: [push]jobs: build: runs-on: ubuntu-latest name: Deploying to surge steps: - uses: actions/checkout@v1 - name: Install surge and fire deployment uses: actions/setup-node@v1 with: node-version: 8 - run: npm install -g surge - run: npm install - run: npm run generate - run: surge ./dist/ ${{ secrets.SURGE_DOMAIN }} --token ${{ secrets.SURGE_TOKEN }} 1.satırdaki name bizim iş akış adımız. 3. satırda yer alan bölüm ise bu aksiyon ne zaman devreye gireceği. Biz burada depoya bir push işlemi olduğunda çalışacak şekilde ayarladık. 5. satırda işlerimizi tanımlayacağımızı 6. satırda ise bu işlerden birinin build olacağını 7. satırda bu build işleminin ubuntu’nun son sürümü üzerinde çalışacağını 8. satırda build işleminin adının ne olacağını belirttik. 9. satırda ise adımlarının ne olacağını 10. satırda actions/checkout@v1 kullanılarak deponun elde edileceğini 11. satırda yeni bir adım isim tanımı yapıldı. 12. satırda actions/setup-node@v1 kullanılarak nodejs yapılandırıldı ve 14. satırda hangi sürüm olacağı belirtildi. 15. satır surge cli’ının iş akışımızı çalıştıracak olan ubuntu üzerine kurmayı 16. satır nuxtjs uygulamamızın paketlerini kurmayı 17. satır ise nuxt uygulamamızı deploy etmeye hazır hale getirip ana dizinde dist klasörüne yerleştirmemizi sağlıyor. Peki gelelim 18. satıra. Aslında diğer run komutlarından hiçbir farkı bulunmuyor. Temelde aslında surge cli ile belirli bir klasörü (./dist/) belirleyeceğimiz(uygun olduğundan emin olmalıyız) domaine almış olduğumuz token ile yayınlamayı sağlıyor diyor ve geçiyor olacaktım. Ama orada farklı olan birşey var. \\$ ve \\$ Bunlar Github Actions içerisinde kullanacağımız ama halka açmamamız gereken alanlar. O zaman nereden tanımlanıyor gelin ona bir bakalım. Secret alanları tanımlamaYukarıdan resimden takip ederek buraya ulaşabilirsiniz. Çok basit bir anahtar-değer ikilisi şeklinde gizli verilerimizi tutmamıza yardımcı oluyor. Daha sonra ise iş akışı dosyamızda bunlara \\$ şeklinde erişebiliyoruz. İhtiyacımız olan iki sırrı :) buraya tanımlayalım. Not: SURGE_DOMAIN için örneğin benim-ornek-nuxt-appim.surge.sh gibi olabildiğince benzersiz bir değer vermeye çalışın. O alan adı boşta değilse hata almamız kaçınılmaz. Artık bu depoya bir push yapıldığında bu iş akışı devreye girecek ve uygulamamız surge.sh’a gönderilecek. BitirirkenNuxtJs özelinde bir uygulamanın Github Actions ile Surge.sh’a nasıl deploy edilebileceğini dilim döndüğünce anlatmaya çalıştım. Bu süreçleri kurgulamak oldukça keyiflidir. Umarım sizde deneyimlerken ve okurken keyif alırsınız. İyi çalışmalar diliyorum.","link":"/nuxtjs-uygulamanizi-github-actions-ile-surgesh-a-deploy-etme/"},{"title":"Stencil Bileşen Yaşam Döngüsü","text":"GirişYaşam döngüsü her framework yada library de olduğu gibi Stenciljs’de de önem arz etmektedir. Bir bileşenin yaşam döngüsünü iyi bilmeliyiz ki herhangi bir t anında bileşene müdahale etmek gerekirse bunu nerede yapabileceğimizi kestirebilelim. Aşağıda çağrılma sıralarını dikkate almadan açıklamaya çalışacağım. Sonraki başlıkta ise farklı senaryolarda tam olarak hangi sıra ile çalıştıklarını belirtiyor olacağım. O zaman başlayalım. connectedCallback()Bu metot bileşen DOM’a her bağlandığında çalıştırılır. Bileşenin DOM’a her bağlandığında yapmasını istediğimiz işlemler burada yer alabilir. Not: Bileşen DOM’a ilk bağlandığında connectedCallback() metodu componentWillLoad() metodundan önce çağrılır. Uygulamada bir bileşenin çok kez DOM’a eklenebileceğini yada kaldırılabileceğini dolayısıyla bu metodun defalarca kez çağrılabileceğini unutmamak gerekir. disconnectedCallback()Bu metot bileşenin DOM ile bağlantısı her kesildiğinde çağrılır. connectedCallback() metodunda olduğu gibi bir çok kez çağrılabileceğini unutmamak gerekir. componentWillLoad()Bileşen DOM’a ilk kez bağlandıktan hemen sonra çağrılır. Burada geriye bir Promise return edilerek ilk render işlemi bekletilebilir. Özellikle bileşenin oluşturulması için bir API’ye istek yapılması gerekiyorsa, işlem burada gerçekleştirilebilir. componentDidLoad()Bileşen DOM’a tam olarak yüklendikten ve render işlemi tamamlandıktan sonra bir kez çağrılır. componentWillRender()Her render işlemi öncesinde çağrılır. componentWillLoad() metodunda olduğu gibi geriye bir Promise return ederek render işlemi bekletilebilir. componentDidRender()Her render işlemi sonrasında çağrılır. componentWillUpdate()Prop() veya State() değerleri değiştiğinde bileşen güncellenmeden hemen önce çağrılır. componentWillLoad() metodunda olduğu gibi geriye bir Promise return ederek render işlemi bekletilebilir. Not: Bileşen DOM’a ilk kez eklendiğinde bu metot çağrılmaz. componentDidUpdate()Bileşen güncellendikten hemen sonra çağrılır. Not: Bileşen DOM’a ilk kez eklendiğinde bu metot çağrılmaz. componentDidUnload()Bu metot bileşen DOM’dan kaldırıldığında çağrılır. Bileşen oluştuğunda örneğin setInterval ile bir timer oluşturduysanız bu metotda clearInterval ile gereksiz çalışmasına (bellek tüketmesine/sürpriz sonuçlar oluşturmasına) engel olabilirsiniz. Farklı Senaryolarda Metotların Çalıştırılma SırasıDiyelim bileşeniniz bütün yöntemleri içeriyor olsun. Bu bileşeni DOM’a eklediğinizde, DOM’dan kaldırdığınızda ve tekrar DOM’a eklediğinizde nasıl br sıralama oluyor aşağıdan inceleyelim. Bileşen DOM’a İlk Eklendiğinde connectedCallback() componentWillLoad() componentWillRender() componentDidRender() componentDidLoad() Bileşen DOM’dan Kaldırıldığında disconnectedCallback() componentDidUnload() Bileşen DOM’a İkinci Kez Eklendiğinde connectedCallback() Bileşende Güncelleme Olduğunda componentWillUpdate() componentWillRender() componentDidRender() componentDidUpdate() İç İçe Bileşenlerde Yaşam Döngüsü12345&lt;bilesen-a&gt; &lt;bilesen-b&gt; &lt;bilesen-c&gt;&lt;/bilesen-c&gt; &lt;/bilesen-b&gt;&lt;/bilesen-a&gt; İç içe bileşen kullanımında ise aşağıdaki gibi bir sıra ile metotlar çağırılmaktadır. bilesen-a-componentWillLoad() bilesen-a-componentWillRender() bilesen-b-componentWillLoad() bilesen-b-componentWillRender() bilesen-c-componentWillLoad() bilesen-c-componentWillRender() bilesen-c-componentDidRender() bilesen-c-componentDidLoad() bilesen-b-componentDidRender() bilesen-b-componentDidLoad() bilesen-a-componentDidRender() bilesen-a-componentDidLoad() Not: Bazı bileşenler önceden yüklenmiş olsada metot çağırma sırası yine yukarıdaki gibi olmaktadır. Zaman Uyumsuz Yaşam Döngüsü MetotlarıYazının bazı bölümlerinde componentWillLoad() ve bazı diğer metotların geriye bir Promise return edebildiğinden bahsetmiştik. Şimdi bunu bir örnek ile daha iyi anlamaya çalışalım. Örneğin bileşen ilk kez render edilmeden önce bileşenin oluşumunda sunucudan gelen verilerin kullanılması gerekiyor. Aşağıdaki örneği inceleyelim. 1234567componentWillLoad() { return fetch('https://jsonplaceholder.typicode.com/todos') .then(response =&gt; response.json()) .then(todos =&gt; { this.todos = todos; });} Bileşenin componentWillLoad() metodu geriye bir Promise return ediyor. Dolayısıyla istek sonuçlanana kadar bileşen render edilmeyecek. BitirirkenBu yazı ile stenciljs için önemli bir konu olan yaşam döngüsü metotlarını incelemeye çalıştım. Bir sonraki yazıda görüşmek üzere. Kaynaklar https://stenciljs.com/docs/component-lifecycle","link":"/stencil-bilesen-yasam-dongusu/"},{"title":"Stencil'e Giriş","text":"Nedir?Stencil Ionic ekibi tarafından geliştirilen native web bileşenleri oluşturmak için hazırlanan bir araçtır. Bunun yanında sanal dom, reaktif veri aktarımı Typescript ve JSX gibi güçlü özellikleri ile uzun vade de oldukça iddialı ve umut verici görünüyor. İlk olarak Polymer Summit 2017 de duyurulan Stencil ben de dahil olmak üzere bir çok kişinin ilgisini çekmiş gibi görünüyor. Bu yazı ile kısa bir giriş yaparak basit bir örnek uygulama hazırlayacağız. Neden?Ekip Ionic bileşenlerinin bir sonraki sürümünü Stencil ile geliştirecek. Bu Ionic ile geliştirilmiş olan uygulamalara ciddi bir hız katacak ve aynı zamanda ciddi bir paket boyutu avantajı sağlayacak gibi görünüyor. Bunun yanı sıra Angular 4 ile Ionic uygulamarı geliştirmek hala mümkün olacak ve daha da önemlisi ve bana çok cazip gelen tarafı Angular 4 dışında Vue, React ve hatta saf Javascript ile ionic uygulamaları geliştirmek mümkün hale gelecek. Yani kısacası framework yada kütüphane bağımsız bir bileşen setine dönüşecek. Gerçekten kulağa çok hoş geliyor. Dikkat: Stencil henüz alpha bile diyemeyeceğimiz çok ama çok erken bir sürümde. Bu nedenle ilk kararlı sürüm yayınlanana kadar dikkatli olunması ve değişimlerin iyi izlenmesi gerekmektedir. Çünkü bazı klavye bükücü anlamsız hatalar ve kararlı sürüme kadar bolca “breaking change” bizleri bekliyor olabilir. KurulumŞu anda Stencil çok erken bir aşamada olduğu için bir cli aracı bulunmuyor. Bu nedenle hızlıca bir göz atmanın en iyi yolu ekip tarafından github üzerindeki başlangıç uygulaması reposunu bilgisayarımıza klonlamak (git clone)olacaktır. O zaman başlayalım: 1$ git clone https://github.com/ionic-team/stencil-starter.git ilk-stencil-ornegi Klonlama işlemi tamamlandıktan sonra bağımlılıklar için klasör içerisine girip npm yada yarn ile yükleme işlemini tamamlıyoruz. 1234$ cd ilk-stencil-ornegi$ npm install#veya yarn için$ yarn Yükleme işlemi tamamlandıktan sonra projeyi yerel bir sunucu üzerinde ayağa kaldırmak için şu komutu çalıştırıyoruz: 123$ npm start# veya yarn için$ yarn start Hadi BaşlayalımStencil bileşenleri Typescript ve JSX kullanılarak oluşturuluyorlar. Bu hem Angular severlere hemde React severlere göz kırpıyor. Vue severler için zaten bir şey söylememe gerek yok. Kim gözünü nereye kırpsa sekip onlara geliyor. :) Bileşenler /src/components/ klasöründe bulunuyor. Bir bileşenin yapısına kısaca bir göz atmak istersek (my-name.tsx): 12345678910111213141516import { Component, Prop } from \"@stencil/core\";@Component({ tag: \"my-name\", styleUrl: \"my-name.scss\"})export class MyName { @Prop() first: string; @Prop() last: string; render() { return ( &lt;p&gt; Hello, my name is {this.first} {this.last} &lt;/p&gt; ); }} @Component: Bileşen için gereken meta verilerin tanımlanması için kullanılan dekorator. Bazı özellikleri tag, styleUrl, styleUrls. @Prop: Bileşenin kabul ettiği öz niteliklerin değerlerini ele alırken kullanılan dekorator. Örneğin @Prop() adi: string = ; Bu bileşenin Stencil yapılandırma dosyasında tanımlanması gerekmektedir. Kontrol etmek için ana dizinde bulunan stencil.config.js dosyasına göz atalım: 1234exports.config = { bundles: [{ components: [\"my-name\", \"diger-bilesen\"] }]};//... Artık bileşeni index.html içerisinde tag adı ile kullanabiliriz: 1234567891011&lt;!DOCTYPE html&gt;&lt;html dir=\"ltr\" lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;Stencil Starter App&lt;/title&gt; &lt;script src=\"build/app.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;my-name first=\"Stencil\" last=\"JS\"&gt;&lt;/my-name&gt; &lt;/body&gt;&lt;/html&gt; Kendi Bileşenimizi GeliştirelimÖncelikle bileşeni geliştirmeye başlamadan önce ilk kez kullanacağımız 3 yeni kavrama bir göz atalım. @State() : Bileşen içerisinde kullanacağımız değişkenleri belirttiğimiz dekarator. Örneğin, @State() deger: number; componentWillLoad : Yaşam döngüsü kancalarından bir tanesi. Bileşen yüklenmeden önce çalıştırılır. Diğerleri, componentDidLoad ve componentDidUnload. componentDidLoad, bileşen yüklendikten sonra componentDidUnload ise bileşen kaldırıldığında çalıştırılır. onClick : Buttona tıklama olayını ele alacağımız event. Örneğin, onClick={() =&gt; this.artir()} Şimdi ilk olarak /src/components/ dizinin içerisine ornek-sayac adında yeni bir bileşen dizini oluşturalım. Şimdi ise içerisine ornek-sayac.tsx ve ornek-sayac.scss dosyalarını oluşturalım. Son görünüm aşağıdaki gibi. Daha sonra yeni bileşenimizi stencil’e haber vermemiz gerekiyor. Bunun için stencil.config.js içerisindeki components string dizisine yeni bileşenimizi ekleyelim. 1234exports.config = { bundles: [{ components: [\"my-name\", \"ornek-sayac\"] }]};//... Şimdi ornek-sayac.tsx dosyasını açalım ve aşağıdaki şekilde düzenleyelim. 1234567891011121314151617181920212223242526272829303132import { Component, Prop, State } from \"@stencil/core\";@Component({ tag: \"ornek-sayac\", styleUrl: \"ornek-sayac.scss\"})export class OrnekSayac { @Prop() baslangic: number = 1; @Prop() artismiktari: number = 5; @State() deger: number; componentWillLoad() { this.deger = this.baslangic; } render() { return ( &lt;p&gt; &lt;button onClick={() =&gt; this.azalt()}&gt;Azalt&lt;/button&gt; &lt;span class=\"sonuc\"&gt;{this.deger}&lt;/span&gt; &lt;button onClick={() =&gt; this.artir()}&gt;Artır&lt;/button&gt; &lt;/p&gt; ); } artir() { const yeniDeger = this.deger + this.artismiktari; this.deger = yeniDeger; } azalt() { const yeniDeger = this.deger - this.artismiktari; this.deger = yeniDeger; }}//... Şimdi ise isteğe bağlı olarak ornek-sayac.scss dosyasını aşağıdaki gibi düzenleyebilirsiniz. 12345678button { font-size: 20px;}.sonuc { padding: 0 10px 0 10px; font-size: 20px; font-weight: bold;} Ve bileşenimiz hazır durumda. Son olarak bileşeni index.html‘e eklemeliyiz. 12345678910111213&lt;!DOCTYPE html&gt;&lt;html dir=\"ltr\" lang=\"en\"&gt; &lt;head&gt; &lt;meta charset=\"utf-8\" /&gt; &lt;title&gt;Stencil Starter App&lt;/title&gt; &lt;script src=\"build/app.js\"&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;my-name first=\"Stencil\" last=\"JS\"&gt;&lt;/my-name&gt; &lt;ornek-sayac&gt;&lt;/ornek-sayac&gt; &lt;!-- &lt;ornek-sayac baslangic=\"5\" artismiktari=\"10\"&gt;&lt;/ornek-sayac&gt; --&gt; &lt;/body&gt;&lt;/html&gt; Sonuç aşağıdaki gibi olmalı. Bu yazı ile temel anlamda Stencil aracına bir giriş yapmış olduk. Yeni konularla bu yazı dizisini devam ettirmeye çalışacağım. Herkese iyi çalışmalar dilerim.","link":"/stencil-e-giris/"},{"title":"Stencil’de Bileşenler Arası Haberleşme","text":"Stencil aracının ne olduğuna bir önceki yazımda giriş seviyesinde değinmeye çalışmıştım. Şimdi biraz daha derinlerine inmeye çalışacağım. Bileşen temelli araçların hemen tümünde bileşenler arası haberleşme/etkileşim (component communication/interaction) önem arz eder. Bu nedenle değineceğim ilk konu bu olacak. Stencil aracında bileşenler arasındaki haberleşme Üst Bileşenden Alt Bileşene (Parent to Child), Alt Bileşenden Üst Bileşene (Child to Parent) olmak üzere iki şekilde gerçekleşmektedir. Aşağıdaki hazırladığım görsel ile basit bir şekilde bu haberleşmeyi anlatmaya çalıştım. Üst Bileşen’den Alt Bileşene (Parent to Child)Bileşenler arasındaki haberleşmenin en anlaşılır ve kolay olanıdır. Alt bileşen içerisinde bir @Prop() tanımlanır ve özellik olarak değer ataması yapılır. Basit bir örnek ile gösterecek olursak : Not: Örnek dilini belki makaleyi yabancı okurlarda inceleyebilir diye affınıza sığınarak İngilizce tutmaya çalışacağım. 123456//*** profile-image.tsx@Prop() imageUrl: string = '';render(){ return(&lt;img src={this.imageUrl} alt=\"My profile image\" /&gt;)}//*** Alt bileşenimiz de imgUrl adında bir özellik alabileceğimizi belirtiyoruz. Ve gelen veriyi img tagının src’sine aktarıyoruz. Daha sonra bu bileşeni kullanacak olan profile bileşenini düzenliyoruz: 123456789101112131415//*** profile.tsx@State() currentUser: any = {name:'Selçuk Kütük',image:'http://localhost:3333/img/profileimg.jpeg'}render(){return ( &lt;div&gt; &lt;h3&gt;Hello {this.currentUser.name}&lt;/h3&gt; &lt;hr /&gt; &lt;profile-image image-url={this.currentUser.image}&gt;&lt;/profile-image&gt; )}//*** Profile bileşenin içerisinde profile-image bileşenini kullanırken bu bileşenin image-url özelliğine profile bileşeninde bulunan currentUser nesnesinin image özelliğini gönderiyoruz. Not: Süslü parantez (curly braces) “{}” JSX söz diziminde Javascript’e geçtiğinizi belirtmek için kullanılır. Böylece bileşen içerisinde yer alan bir değişkenin değerini bir html özelliğine aktarabiliriz. 1&lt;profile&gt;&lt;/profile&gt; Alt Bileşen’den Üst Bileşene (Child to Parent)Mantığı basit olmasına karşın anlaşılması ilk haberleşme şekline göre biraz daha zordur. Öncelikle sorunu bir tanımlayalım. Bu haberleşmede amiyane tabirle bileşen elimizin altında değil. Aksi gibi elimizin üstünde :). Bu nedenle Alt bileşende gerçekleşen bir olaydan haberdar olmak ve varsa gerçekleşen olayın sonucunda oluşan değeri de elde etmek istiyoruz. İşte tam burada 3 yeni kavram karşımıza çıkıyor. @Event() ve @Listen() dekarator’ü, EventEmitter arayüzü. @Event(): Tanımlanacak değişkenin üst bileşenlere haber göndereceğini işaretlemeye yarayan dekarator. Örneğin, @Event() profileImageUpdated: EventEmitter; EventEmitter: Tanımlanan değişkenin tipini ifade eder. İçerisinde bulunan emit methodu ile Üst bileşenlere haber ve gerekirse veri gönderir. Örneğin, profImgUpd.emit(‘newprofileimg.jpeg’) @Listen(): Üst bileşende işaretlenen method ile Alt bileşendeki gerçekleşen bir olaydan haberdar olunmasını sağlayan dekarator. Örneğin, @Listen(‘profileImageUpdated’) showInfo(event: CustomEvent){console.log(event.detail)} O zaman ilk örneğimizi bu yeni konu ile genişletelim: Not: Event, EventEmitter, Listen @stencil/core kütüphanesinde yer almaktadır. Dahil etmeyi unutmayın. 1import {Event, EventEmitter, Listen} from ‘@stencil/core’; Şimdi profile-image bileşeninde ki işlemleri gerçekleştirelim. 1234567891011121314//*** profile-image.tsx@Prop() imageUrl: string = '';@Event() profileImageUpdated: EventEmitter;updateProfileImage(){ let newProfileImageUrl = '...'; this.profileImageUpdated(newProfileImageUrl);}render(){ return( &lt;button onClick={() =&gt; this.updateProfileImage()}&gt;Update&lt;/button&gt; &lt;img src={this.imageUrl} alt=\"My profile image\" /&gt; )}//*** Şimdi ise profile bileşeninde ki işlemleri gerçekleştirelim. 123456789101112131415161718192021222324252627//*** profile.tsx@State() currentUser: any = { name:'Selçuk Kütük', image:'http://localhost:3333/img/profileimg.jpeg'}@State() newProfileUrl: string = '';@Listen('profileImageUpdated')profileImageUpdatedHandler(event: CustomEvent){ this.newProfileUrl = event.detail;}render(){ return ( { this.imageUrl !== '' &amp;&amp; &lt;span&gt; Profile image updated. New image: &lt;img src={this.newProfileUrl} alt=\"New image\" /&gt; &lt;/span&gt; } &lt;h3&gt;Hello {this.currentUser.name}&lt;/h3&gt; &lt;hr /&gt; &lt;profile-image image-url={this.currentUser.img}&gt;&lt;/profile-image&gt; )}//*** Şimdi haberleşmenin keyfini çıkaralım. Stencil yazı dizisinin ikincisinde bileşenler arasındaki haberleşmeyi ele almaya çalıştım. Bir sonraki konuda görüşmek üzere. Herkese iyi çalışmalar dilerim.","link":"/stencilde-bilesenler-arasi-haberlesme/"},{"title":"VueJs ile Axios Kullanımı","text":"Çok az sayıda framework/library yerleşik bir http API’si bulundurur. Örneğin AngularJs ile birlikte $http, Angular 2+ da ise HttpModule ve HttpClientModule (HttpModule Angular 9 ile tamamen kaldırılacak.), JQuery tarafında ise $.ajax yerleşik olarak bulunuyordu. VueJs 2.0’a kadar ise benzer şekilde vue-resource ile işlemlerimizi yerleşik olarak yapabiliyorduk. Fakat VueJs ekibi bunun VueJs 2.0 ile birlikte ayrılması gerektiğine ve 3. parti kütüphanelerin buna daha iyi hizmet edebileceğine karar verdiler. Bunun için en çok önerilen ise Axios‘tur.Axios ile http işlemlerinizi çok basit ve etkili bir şekilde çözebilirsiniz. Varsayılan olarak Promise kullanır. Hem istemcide hemde sunucuda çalışır (SSR için uygun). VueJs ile kullanımı da oldukça basittir. Aynı zamanda async/await ile birlikte tertemiz bir kullanım sağlar. O zaman kurulum ile başlayalım incelemeye. Not: VueJs uygulamasının zaten olduğu varsayılmıştır. 12345#Yarn$ yarn add axios#NPMnpm i axios Kurulum tamamlandıktan sonra en temel iki metot olan GET ve POST olaylarını inceleyelim. Uygulamada API olarak jsonplaceholder kullanılmıştır. axios.get()12345678910111213141516171819202122232425262728293031323334353637&lt;template&gt; &lt;div id=\"axios-get\"&gt; &lt;ul&gt; &lt;li v-for=\"post of posts\" :key=\"post.id\"&gt;{{ post.title }}&lt;/li&gt; &lt;/ul&gt; &lt;ul v-if=\"errors &amp;&amp; errors.length\"&gt; &lt;li v-for=\"(error, index) of errors\" :key=\"index\"&gt; {{ index + 1 }} - {{ error.message }} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import axios from \"axios\"; export default { created() { this.getPosts(); }, data() { return { posts: [], errors: [] }; }, methods: { getPosts() { axios .get(\"https://jsonplaceholder.typicode.com/posts\") .then(response =&gt; (this.posts = response.data)) .catch(error =&gt; { this.errors.push(error); }); } } };&lt;/script&gt; axios.post()12345678910111213141516171819202122232425262728293031323334353637383940414243444546&lt;template&gt; &lt;div id=\"axios-post\"&gt; &lt;form @submit.prevent=\"sendNewPost\"&gt; &lt;label for=\"title\"&gt;Başlık:&lt;/label&gt; &lt;input name=\"title\" type=\"text\" v-model=\"newPost.title\" /&gt; &lt;button type=\"submit\" :disabled=\"inProgress\"&gt;Kaydet&lt;/button&gt; &lt;/form&gt; &lt;div v-if=\"sendNewPostResult\"&gt; Oluşan Post &lt;pre&gt;{{ sendNewPostResult }}&lt;/pre&gt; &lt;/div&gt; &lt;ul v-if=\"errors &amp;&amp; errors.length\"&gt; &lt;li v-for=\"(error, index) of errors\" :key=\"index\"&gt; {{ index + 1 }} - {{ error.message }} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import axios from \"axios\"; export default { data() { return { inProgress: false, errors: [], newPost: { title: \"\" }, sendNewPostResult: null }; }, methods: { sendNewPost() { this.inProgress = true; axios .post(\"https://jsonplaceholder.typicode.com/posts\", this.newPost) .then(response =&gt; (this.sendNewPostResult = response.data)) .catch(error =&gt; { this.errors.push(error); }) .finally(() =&gt; (this.inProgress = false)); } } };&lt;/script&gt; Axios async/await kullanmaAxios Promise kullandığı için await anahtarı ile sonucunu bekletebiliriz. Aşağıda daha önce yaptığımız get örneğini async/await ile birlikte nasıl kullanabileceğimizi göstermeye çalıştım. Burada unutulmaması gereken await anahtarı kullanılabilmesi için metodun async anahtarı ile işaretlenmiş olması. 123456789101112131415161718192021222324252627282930313233343536373839&lt;template&gt; &lt;div id=\"axios-get\"&gt; &lt;ul&gt; &lt;li v-for=\"post of posts\" :key=\"post.id\"&gt;{{ post.title }}&lt;/li&gt; &lt;/ul&gt; &lt;ul v-if=\"errors &amp;&amp; errors.length\"&gt; &lt;li v-for=\"(error, index) of errors\" :key=\"index\"&gt; {{ index + 1 }} - {{ error.message }} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; import axios from \"axios\"; export default { async created() { await this.getPostsAsync(); }, data() { return { posts: [], errors: [] }; }, methods: { async getPostsAsync() { try { const response = await axios.get( \"https://jsonplaceholder.typicode.com/posts\" ); this.posts = response.data; } catch (error) { this.errors.push(error); } } } };&lt;/script&gt; Axios’u Global olarak kullanmaAxios’u global olarak etkili bir şekilde kullanmak için Vue örneğinin prototype’ine yeni bir property tanımlayacağız. Bunu farklı şekillerde yapabilsekte kafa karışmaması adına main.js içerisinde direkt olarak yapacağız. Not: Daha temiz görünmesi için ayrı bir script dosyasında yapılandırabilir ve main.js içerisinden import edebilirdik. 12345678import Vue from \"vue\";import axios from \"axios\";const axiosInstance = axios.create({ baseURL: \"https://jsonplaceholder.typicode.com/\"});Vue.prototype.$axios = axiosInstance; Bu yapılandırmadan sonra artık axios’a bileşenlerimizden this.\\$axios ile ulaşabileceğiz. Aşağıdaki örneği inceleyelim. 123456789101112131415161718192021222324252627282930313233343536&lt;template&gt; &lt;div id=\"axios-global\"&gt; &lt;ul&gt; &lt;li v-for=\"post of posts\" :key=\"post.id\"&gt;{{ post.title }}&lt;/li&gt; &lt;/ul&gt; &lt;ul v-if=\"errors &amp;&amp; errors.length\"&gt; &lt;li v-for=\"(error, index) of errors\" :key=\"index\"&gt; {{ index + 1 }} - {{ error.message }} &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt; export default { async created() { await this.getPostsAsync(); }, data() { return { posts: [], errors: [] }; }, methods: { async getPostsAsync() { try { const response = await this.$axios.get(\"/posts\"); this.posts = response.data; } catch (error) { this.errors.push(error); } } } };&lt;/script&gt; Global olarak kullanma typescript detayıEğer VueJs uygulamanızı typescript ile geliştiriyorsanız bu küçük kod ile global olarak kullanırken vscode gibi editörler için intellisense desteği ekleyebilirsiniz. src klasörü altında shims-axios.d.ts adı ile bir dosya oluşturun ve aşağıdaki kod parçasını içerisine ekleyin.1234567import { AxiosInstance } from \"axios\";declare module \"vue/types/vue\" { interface Vue { $axios: AxiosInstance; }} Axios request/response interceptorInterceptor araya giren anlamında bir kelime. Peki bu ne anlama geliyor. Bir http isteği oluşturulduğunda sunucuya gitmeden önce yada istek sonucu döndükten hemen sonra merkezi bir noktada son bir dokunuş yapmamız gerekebilir. Ben çok ihtiyaç duyulan iki örnek ile bunu anlatmaya çalışacağım. Request InterceptorBir istek yapacaksınız ama istek sunucuya gitmeden hemen önce header’a Authorization bilgisi eklemek istiyorsunuz. Request interceptor bunun için biçilmiş kaftandır.Örneği inceleyelim. 1234567891011121314import Vue from \"vue\";import axios from \"axios\";const axiosInstance = axios.create({ baseURL: \"https://jsonplaceholder.typicode.com/\"});Vue.prototype.$axios = axiosInstance;axiosInstance.interceptors.request.use(config =&gt; { //Tabiki burada token değerini local yada session storage gibi bir yerden okumamız gerekebilir config.headers[\"Authorization\"] = \"Bearer eyxxxx\"; return config;}); Artık tüm isteklerin header’ına bu değer ekleniyor olacak. Response InterceptorBuradaki örneğimizde ise mesela sunucudan cevap döndüğünde eğer bir hata var ise bir toast mesajı göstermek isteyebilirsiniz. Diğer bir örnek ise istek sonucunda 401 hata kodu aldığımızda token’ı yenilemek yada kullanıcıyı giriş sayfasına yönlendirmek isteyebiliriz. Çözüm işte tam burası. 123456789101112131415import Vue from \"vue\";import axios from \"axios\";const axiosInstance = axios.create({ baseURL: \"https://jsonplaceholder.typicode.com/\"});Vue.prototype.$axios = axiosInstance;axiosInstance.interceptors.response.use(config =&gt; { if (config.status === 401) { alert(\"Oturum süreniz sona erdi\"); } return config;}); BitirirkenBu yazı ile vue ile axios kütüphanesinin en sık ihtiyaç duyulan bölümlerini ele almaya çalıştım. Gerçekten çok başarılı bir kütüphane olduğunu belirtmekte fayda var. Tüm yapılandırma seçeneklerini incelemek için github deposunu ziyaret etmekte fayda var. Herkese iyi çalışmalar dilerim. Örnek Github Adresi: https://github.com/selcukkutuk/vue-axios-examplesKaynaklar https://github.com/axios/axios https://alligator.io/vuejs/rest-api-axios/","link":"/vuejs-ile-axios-kullanimi/"}],"tags":[{"name":"nuxtjs","slug":"nuxtjs","link":"/etiketler/nuxtjs/"},{"name":"githubactions","slug":"githubactions","link":"/etiketler/githubactions/"},{"name":"surgesh","slug":"surgesh","link":"/etiketler/surgesh/"},{"name":"stenciljs","slug":"stenciljs","link":"/etiketler/stenciljs/"},{"name":"web components","slug":"web-components","link":"/etiketler/web-components/"},{"name":"lifecycle methods","slug":"lifecycle-methods","link":"/etiketler/lifecycle-methods/"},{"name":"bileşen iletişimi","slug":"bilesen-iletisimi","link":"/etiketler/bilesen-iletisimi/"},{"name":"vuejs","slug":"vuejs","link":"/etiketler/vuejs/"},{"name":"axios","slug":"axios","link":"/etiketler/axios/"},{"name":"interceptor","slug":"interceptor","link":"/etiketler/interceptor/"}],"categories":[{"name":"DevOps","slug":"DevOps","link":"/kategoriler/DevOps/"},{"name":"Web Components","slug":"Web-Components","link":"/kategoriler/Web-Components/"},{"name":"VueJs","slug":"VueJs","link":"/kategoriler/VueJs/"}]}